<!DOCTYPE html>
<html lang="fr">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
    <style media="screen">
    @font-face {
      font-family: SourceSansVariable;
      font-weight: 100 800;
      src: url(_fonts/SourceSans3VF-Roman.ttf.woff2) format("woff2");
    }

    * {
      margin: 0;
      padding: 0;
    }

    :root {
      --forme: #999;
      --fond: #222;
      --fondApp: #000;
      --hl: yellow;
      --pixel: white;
      --gap: .5rem;
      --alerte: #eee;
      --grille: 8;
      --curseur: pointer;
      --coulPicto: #aaa;
    }

    html {
      font-size: 100%;
      /* 1rem = 1em = 16px */
    }

    body {
      line-height: 120%;
      display: flex;
      justify-content: center;
      align-items: center;
      /* deco */
      background-color: var(--fondApp);
      font-family: SourceSansVariable;
      font-weight: 100;
      height: 100vh;
      /*
        height: 50vh; */
      /* margin-left: calc(50vw - calc(calc(100vh / 16) * 4.5)); */
    }

    main {
      display: grid;
      grid-gap: var(--gap);
      /* grid-template-columns: repeat(3, minmax(0, 1fr)); */
      background-color: #111;
      border-radius: 1rem;
      height: calc( 50vh - calc (var(--grille) * var(--gap)));
      /* overflow: hidden; */
    }

    article {
      /* height: 25vh; */
      height: calc(50vh / var(--grille));
      width: calc(50vh / var(--grille));
      background-color: var(--fond);
      /* border-radius: 50%; */
    }

    article:hover {
      cursor: var(--curseur);
    }

    .allume {
      background-color: var(--pixel);
    }

    #actions, #tools {
      display: flex;
      justify-content: space-around;
      align-items: center;
      /* width: calc(80vw - 1rem); */
      padding: 0 .5rem;
      height: 3rem;
      position: fixed;
      /* border-radius: 1rem; */
      /* border-top-left-radius: 1rem;
        border-top-right-radius: 1rem; */
      /* border: 1px solid var(--forme); */
      background-color: #222;
      font-size: .8rem;
      box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, .33);
      transition: all 600ms ease-in-out;
    }

    #actions {
      bottom: 1rem;
      width: 360px;
      left: calc(calc(50vw - calc(180px + 6rem)) - 1rem);
      border-top-left-radius: 1rem;
      border-bottom-left-radius: 1rem;
    }

    #tools {
      bottom: 1rem;
      width: 12rem;
      left: calc(calc(50vw + calc(180px - 6rem)) + .25rem);
      border-top-right-radius: 1rem;
      border-bottom-right-radius: 1rem;
    }

    #actions p,
    #speed p {
      background-color: #888;
      color: var(--hl);
      border-radius: 8px;
      font-weight: 600;
      padding: 0px 8px;
      line-height: 2rem;
      font-size: 2rem;
      font-weight: 400;
      width: 3ch;
      text-align: right;
    }

    #actions label {
      color: var(--forme);
    }

    #speed {
      position: fixed;
      display: flex;
      flex-direction: column;
      left: calc(calc(calc(100vw - calc(calc(100vh / 16) * 9)) / 4) - 2rem);
      top: 0;
      /* calc(50vh - 3vw); */
      width: 2rem;
      height: 25vh;
      background-color: #222;
      border-radius: 0 0 1rem 1rem;
      padding: 1rem;
      justify-content: flex-end;
      align-items: center;
      box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, .33);
    }

    #speed datalist {
      /* display: flex;
        flex-direction: column;
        justify-content: space-between;
        /* writing-mode: vertical-lr; */
      width: 200px;
      background-color: var(--hl);
    }
    #speed input {
      appearance: slider-vertical;

      /* width: 50vh; */
      /* transform: rotateZ(-90deg); */
    }
    #speed {
      accent-color: var(--hl);
      -webkit-accent-color: var(--hl);
    }

    #speed p {
      /* transform: rotateZ(90deg); */
      /* margin-right: 1rem; */
      /* height: 2rem; */
      width: 2ch;
      font-size: 1.5rem;
      margin-top: 1rem;
    }

    #size {
      display: flex;
      justify-content: space-around;
      align-items: center;
      padding: 0 .5rem;
      /* width: calc(80vw - 1rem); */
      width: 450px;
      left: calc(50vw - 225px);
      /* height: 5vh; */
      position: fixed;
      top: 0rem;
      /* left: 10vw; */
      border-bottom-left-radius: 1rem;
      border-bottom-right-radius: 1rem;
      line-height: 3rem;
      color: var(--forme);
      /* border: 1px solid var(--forme); */
      background-color: var(--fond);
      box-shadow: 0px 0px 8px 0px rgba(0, 0, 0, .33);
    }

    #size div {
      width: calc(100% - 4rem);
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    #size input {}

    #size label {
      vertical-align: super;
      font-weight: 700;
      font-size: 1.5rem
    }

    .hl {
      /* background-color: var(--hl) !important; */
    }

    /* pictos interface */
    #close {
      background-color: #aaa;
      mask: url(_medias/x-circle.svg) center no-repeat;
      -webkit-mask: url(_medias/x-circle.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #close:hover,
    #upload:hover,
    #uploadPlayer:hover,
    #download:hover,
    #previous:hover,
    #next:hover,
    #erase:hover,
    #add:hover,
    #pU:hover, #pD:hover,#pL:hover, #pR:hover, #inv:hover {
      background-color: var(--hl);
    }

    #close,
    #upload,
    #uploadPlayer,
    #download,
    #previous,
    #next,
    #erase,
    #add,
    #pU, #pD,#pL, #pR, #inv
    #play {
      transition: background-color 300ms ease-in-out;
    }

    #play:hover {
      background-color: white;
    }

    #pU {
      background-color: var(--coulPicto);
      mask: url(_medias/pix_u_3.svg) center no-repeat;
      -webkit-mask: url(_medias/pix_u_3.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }
    #pD {
      background-color: var(--coulPicto);
      mask: url(_medias/pix_d_3.svg) center no-repeat;
      -webkit-mask: url(_medias/pix_d_3.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }
    #pL {
      background-color: var(--coulPicto);
      mask: url(_medias/p_l_3.svg) center no-repeat;
      -webkit-mask: url(_medias/pix_l_3.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }
    #pR {
      background-color: var(--coulPicto);
      mask: url(_medias/pix_r_3.svg) center no-repeat;
      -webkit-mask: url(_medias/pix_r_3.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }
    #inv {
      background-color: var(--coulPicto);
      mask: url(_medias/pix_inv.svg) center no-repeat;
      -webkit-mask: url(_medias/pix_inv.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #download {
      background-color: var(--coulPicto);
      mask: url(_medias/save.svg) center no-repeat;
      -webkit-mask: url(_medias/save.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #serial {
      background-color: var(--hl);
      mask: url(_medias/link.svg) center no-repeat;
      -webkit-mask: url(_medias/link.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
      /* margin: 0 1rem; */
    }

    #upload,
    #uploadPlayer {
      background-color: var(--coulPicto);
      mask: url(_medias/download.svg) center no-repeat;
      -webkit-mask: url(_medias/download.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      position: relative;
      display: inline-block;
      overflow: hidden;
      cursor: pointer;
    }

    #upload input,
    #uploadPlayer input {
      width: 100%;
      height: 100%;
      cursor: pointer;
      position: absolute;
      opacity: 0;
    }

    #previous {
      background-color: #eee;
      mask: url(_medias/skip-back.svg) center no-repeat;
      -webkit-mask: url(_medias/skip-back.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #next {
      background-color: #eee;
      mask: url(_medias/skip-forward.svg) center no-repeat;
      -webkit-mask: url(_medias/skip-forward.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #play {
      background-color: var(--hl);
      mask: url(_medias/play.svg) center no-repeat;
      -webkit-mask: url(_medias/play.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #erase {
      background-color: var(--coulPicto);
      mask: url(_medias/trash.svg) center no-repeat;
      -webkit-mask: url(_medias/trash.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    #add {
      background-color: var(--coulPicto);
      mask: url(_medias/plus-square.svg) center no-repeat;
      -webkit-mask: url(_medias/plus-square.svg) center no-repeat;
      width: 1.5rem;
      height: 1.5rem;
      text-indent: -300vw;
    }

    input#clearNewFrame {
      /* width: 2rem; */
    }

    svg {
      fill: currentColor;
    }

    footer {
      position: fixed;
      display: flex;
      justify-content: center;
      align-items: center;
      bottom: 1.5rem;
      left: 1.5rem;
      width: 2rem;
      height: 2rem;
      border-radius: 1rem;
      background-color: var(--forme);
    }

    /* pour version matrice 8x8 - animator 10b */
    #size>div {
      display: none;
    }

    #size {
      height: 3rem;
      width: 100px;
      left: calc(50vw - 50px);
    }

    .sizeMatrix {
      width: calc(100px + 8rem)!important;
      left: calc(50vw - calc(calc(100px + 8rem) / 2))!important;
    }
    .showMatrix {
      display: flex!important;
    }

    article {
      border-radius: 50%;
    }

    main {
      padding: 1rem;
    }
    /* rotation matrice */
    #rot {
      border-left: 2px solid #444;
      display: none;
      list-style: none;
      width: 8rem;
      /* height: 3rem; */
      /* background-color: #333; */
      justify-content: space-around;
      /* padding: 0 .5rem 1rem .5rem; */
      /* border-bottom-right-radius: 1.5rem; */
      /* margin: 1rem; */
      padding-left: 3rem;
      /* margin-left: 1rem; */
      background: url(_medias/matrix.svg) 1rem 50% no-repeat;
      background-size: 12%;
    }
    #rot li {
      /* text-indent: -300rem; */
      position: relative;
      width: 2.5rem;
      height: 2.5rem;
      /* margin-top: 1rem; */
    }
    #rot li a {
      position: absolute;
      text-indent: -300vw;
      width: 100%;
      height: 100%;
    }
    .rot0 {
      background-color: var(--coulPicto);
      /* background: url(_medias/rot_0.svg) no-repeat; */
      mask: url(_medias/rot_0.svg) center no-repeat;
      -webkit-mask: url(_medias/rot_0.svg) center no-repeat;
    }
    .rot90 {
      background-color: var(--coulPicto);
      width: 1.5rem;
      height: 1.5rem;
      /* text-indent: -300vw; */
      mask: url(_medias/rot_90.svg) center no-repeat;
      -webkit-mask: url(_medias/rot_90.svg) center no-repeat;
    }
    .rot180 {
      background-color: var(--coulPicto);
      width: 1.5rem;
      height: 1.5rem;
      mask: url(_medias/rot_180.svg) center no-repeat;
      -webkit-mask: url(_medias/rot_180.svg) center no-repeat;
    }
    .rot270 {
      background-color: var(--coulPicto);
      width: 1.5rem;
      height: 1.5rem;
      mask: url(_medias/rot_270.svg) center no-repeat;
      -webkit-mask: url(_medias/rot_270.svg) center no-repeat;
    }
    #rot li a {
      transition: background-color 300ms ease-in-out;
    }
    #rot li:first-of-type {
      /* margin-left: 2rem; */
    }
    #rot li a:hover {
      background-color: var(--hl);
    }
    .selected {
      background-color: var(--hl);
    }
    </style>
  </head>

  <body>
    <main></main>
    <aside id="speed">
      <input oninput="majVitesse(this)" type="range" id="vitesse" name="vitesse" value="8" min="8" max="30" list="markers" orient="vertical">
      <datalist id="markers">
        <option value="8" label="8"></option>
        <option value="12" label="12"></option>
        <option value="15" label="15"></option>
        <option value="25" label="25"></option>
        <option value="30" label="30"></option>
      </datalist>
      <p id="vitesseTxt">8</p>
    </aside>
    <aside id="size">
      <span title="charger une anim." id="upload">
        <input type="file" onchange="importe(this)">
      </span>
      <a id="serial" title="connectez la board" onclick="connectSerial(this)" href="#">port série</a>
      <!-- <button id="serial">Connectez le port série...</button> -->
      <!-- <a href="#" onclick="importe(this)">Import anim</a> -->
      <ul id="rot">
        <li class="rot0" data-rot=0><a href="#" title="Matrice à 0°">0°</a></li>
        <li class="rot90" data-rot=1><a href="#" title="Matrice à -90°">90°</a></li>
        <li class="rot180" data-rot="2"><a href="#" title="Matrice à 90°">180°</a></li>
        <li class="rot270" data-rot="3"><a href="#" title="Matrice à 180°">270°</a></li>
      </ul>
      <div>
        <label id="largeurTxt" for="largeur">largeur:</label>
        <input onchange="majDim(this)" type="range" id="largeur" name="largeur" value="8" min="1" max="12">
        <label id="hauteurTxt" for="hauteur">hauteur:</label>
        <input onchange="majDim(this)" type="range" id="hauteur" name="hauteur" value="8" min="1" max="16">
        <a id="close" href="#" title="fermer cet onglet" onclick="ferme(this)"></a>
      </div>
    </aside>
    <aside id="actions">
      <a id="download" title="sauv. l'anim." onclick="saveAnimation(this)" href="#">Save</a>
      <span title="charger une anim." id="uploadPlayer">
        <input type="file" onchange="importe(this)">
      </span>
      <p>0</p>
      <a id="previous" onclick="previous()" title="img préc." href="javascript:void(0)">previous</a>
      <a id="play" class="hl" onclick="record()" href="javascript:void(0)" title="lire / pause">play/stop</a>
      <a id="next" onclick="next()" href="javascript:void(0)" title="img suiv.">next</a>
      <a id="add" onclick="addFrame()" href="#" title="insérer img">addFrame</a>
      <label id="clearNewFrameLabel">clear next</label>
      <input id="clearNewFrame" checked type="checkbox" />
      <a id="erase" onclick="erase()" href="#" title="supp. img">erase</a>
    </aside>
    <aside id="tools">
      <a id="inv" onclick="pixToggle()" title="Inverser ON-OFF" href="javascript:void(0)">Invert On-Off</a>
      <a id="pU" onclick="pixUp()" title="décaler vers le haut." href="javascript:void(0)">pixel Up</a>
      <a id="pD" onclick="pixDown()" title="décaler vers le bas." href="javascript:void(0)">pixel Down</a>
      <a id="pL" onclick="pixLeft()" title="décaler vers la gauche." href="javascript:void(0)">pixel Left</a>
      <a id="pR" onclick="pixRight()" title="décaler vers la droite." href="javascript:void(0)">pixel Right</a>
    </aside>
    <section></section>
    <footer></footer>
  </body>
  <script>
  /*
      icon from https://feathericons.com/

      v02:
        changement format de l'anim
          animation = {
            dim:[x,y],
            datas:[images]
          }
        ajout dimensionnement de la grille
      v03:
        compteur défile quand anime joue
        le résultat de l'anim s'affiche dans un block qui apparaît dans la page
        ajout d'un bouton pour conserver l'image précédente à l'affichage
        fermeture de la barre de réglage de la grille
      v04:
        changement format de l'anim -> JSON valide
        enregistrement d'un fichier d'anim en local (source: https://code.tutsplus.com/tutorials/how-to-save-a-file-with-javascript--cms-41105)
        import d'un fichier d'anim (source: https://javascript.info/file)
        le nom du fichier contient la date et l'heure (formatage de l'heure)
        correction limite previous() <= 0
        ajout de pictos pour les outils
        corrections de bug
      v05:
        ajout "supprimer l'image en cours"
        ajout "insérer une image"
        transition sur les hover
        changement icône chargement
      v06:
        ajout d'une vitesse dans le fichier d'animation
        arrête la lecture quand chargement d'un fichier
        affichage d'une erreur en cas de pb de chargement de fichier + si pb de taille de grille vs valeur de case
        reconfigure l'interface si ajout "#player" dans l'url
        correction du # dans les href remplacé par (javascript:void(0))
      v07:
        ajout d'un réglage de vitesse
        correction de la suppression d'une image (effectif maintenant)
      v08:
        changement type de fichier sauvegardé -> .json
        sauvegarde en localStorage l'animation quand quitte ou reload la page
        propose de recharger (si présente) l'animation sauvgardée au chargement de la page
      v09:
        ajout de raccourcis clavier pour l'utilisation de Robert (click bouton = Enter) ou boitapotard HID encodeur + 2 boutons [Q(A sur clavier US) et B]
        modification des raccourcis pour ajouter une image.
        les `flèches` servent à se déplacer dans l'anim existante
        `Enter` pour ajouter une image
        flash lumineux lorsqu'on atteint les extrémités de l'anima (début ou fin)
      v10 matrice
        change la taille sur une matrice 8x8 carrée ou 16x8
      alfazeta_v10b
        change la taille de la matrice 7x7 (board XY5)
      v11 : intégration de la connection à l'afficheur XY5 d'Alfazeta via usb-RS485
      v11 matrice :
        matrice 8x8
        connexion au serial_cdc du rp2040 (webusp api)
        envoie d'une image comme enregistré dans le json
        mise au format frame alfazeta buildFrameBuffer()
      v12 matrice
        ajout #tools d'outils de dessins (pixToggle, pixLeft, pixRight, pixUp, pixDown) + pictos
        Màj de la css
          ajout #tools
          modifs placement et design #actions
        ajout des pictos
        ajout raccourcis dessine ligne verticale (Command + Shift) ou horizontale (Command)
        correction : lance la lecture si animation.datas.length > 1
        ajout updateDatas (quand on swichPixel) met à jours animation.datas + sur matrice connectée
        changement "onInput" plutôt que "onchange" sur range #speed
        css: donne une hauteur à la matrice (bug d'affichage parfois)
        renomme final() en saveAnimation()
        suppression des différentes syntaxe requestAnimationFrame (compatible depuis 2012)
        changement couleur de la jauge de vitesse
        cache la connection si non supporté par le navigateur
        ajout de la rotation due l'anim sur la matrice connectée (icones)
        MàJ de la matrice à la connexion
        Si connexion affiche les icones de rotation de la matrice
        la sequence alfazeta conservée (3 + 8 + 1)
        Rotation est le paramètre 3 du header

    */
  // FIXED: ajouter "supprimer l'image en cours" ou "enlever l'image"

  // numero de la version
  const version = parseInt(window.location.pathname.split(".")[1], 10);
  document.querySelector("footer").innerHTML = `v.${version}`;

  // l'animation
  let animation = {
    speed: 8,
    dim: [],
    datas: [],
  };
  // cadence de l'animation
  let fps = animation.speed;
  let enLecture = false;

  const main = document.querySelector("main");
  const compteur = document.querySelector("#actions p");
  // const section = document.querySelector("section");
  const clearNF = document.querySelector("#clearNewFrame");
  const size = document.querySelector('#size');
  const actions = document.querySelector('#actions');
  // const speed = document.querySelector('#speed');
  const speedP = document.querySelector("#speed p");
  const speedR = document.querySelector("#speed input");
  speedR.value = fps;

  let mode = "";
  console.log(window.location.search);
  /* init du mode player */
  if (/player/gm.test(window.location.hash)) {
    console.log("c'est le player");
    mode = "player";
    size.style.display = "none";
    actions.style.width = "220px";
    actions.style.left = "calc(50vw - 110px)";
    document.querySelector('#download').style.display = "none";
    document.querySelector('#add').style.display = "none";
    document.querySelector('#clearNewFrame').style.display = "none";
    document.querySelector('#clearNewFrameLabel').style.display = "none";
    document.querySelector('#erase').style.display = "none";
    document.documentElement.style.setProperty('--gap', 0);
    document.documentElement.style.setProperty('--fond', "#000");
    document.body.style.backgroundColor = "#333";
  } else {
    console.log("c'est l'éditeur");
    mode = "editeur";
    document.querySelector('#uploadPlayer').style.display = "none";
  }

  // var nbr de lignes / colonnes
  let rows = document.querySelector("#hauteur").value;
  document.querySelector("#hauteurTxt").innerHTML = rows;
  let cols = document.querySelector("#largeur").value;
  document.querySelector("#largeurTxt").innerHTML = cols;
  let pixels = [];

  let nImage = 0;
  let nImageLecteur = 0;
  let shift = false;
  let meta = false;

  if (!navigator.serial) {
    document.querySelector("#serial").style.display = "none";
  }
  // pour la connection série
  let writer;
  const switchPixel = (e) => {
    if (meta && !shift) {
      // ligne horizontale
      pixels.forEach((pixel) => {
        if (pixel.dataset.y === e.target.dataset.y) {
          pixel.classList.toggle("allume");
        }
      });
    } else if (meta && shift) {
      // colonne
      pixels.forEach((pixel) => {
        if (pixel.dataset.x === e.target.dataset.x) {
          pixel.classList.toggle("allume");
        }
      });
    } else {
      e.target.classList.toggle("allume");
    }
    // MàJ de l'afficheur XY5 si connecté
    // if (writer !== undefined) {
    //   updateXY5(nImage);
    // }
    updateDatas();
  };

  dessineGrille();

  /* orientation de l'anim sur la matrice connectée */
  const itemRot = document.querySelectorAll("#rot li a");
  let rotEncours = 0;
  document.querySelector(`.rot${rotEncours}`).classList.add("selected");

  itemRot.forEach((item) => {
    item.addEventListener("click", (e) => {
      document.querySelector(`.rot${rotEncours*90}`).classList.remove("selected");
      rotEncours = parseInt(e.target.parentNode.dataset.rot, 10);
      document.querySelector(`.rot${rotEncours*90}`).classList.add("selected");
      //console.log(`rotation Matrcie : ${rotEncours}`)
    });
  });

  /**
   * refactored from : https://github.com/owenmcateer/FlipDots/blob/master/CastCanvas/FlipDots.js
   * Build panel buffer to send.
   *
   * @param {BufferArray} frameData Image data buffer array
   * @return {BufferArray} Buffer data ready to send to device
   */
  function buildFrameBuffer(frameData) {
    // Headers
    const dataHeader = Uint8Array.from([
      0x80, // Start
      0x87, // Command 0x87 (7bits, Refresh, 7x7)
      // 0x88 (7bits, No refresh, 7x7) (requires a further 0x82 to refresh)
      //0xFF, // all panels
      rotEncours, // remplace le all panel par la rotation
    ]);
    /* TODO : envoyer la sequence pivotée sur la matrice pour rester compatible avec XY5 d'alfazeta*/
    // Footer
    const dataFooter = Uint8Array.from([0x8F]);
    // Concat all data
    const cmdBytearray = Uint8Array.from([...dataHeader, ...Uint8Array.from(frameData), ...dataFooter]);
    // Return final buffer
    return cmdBytearray;
  }

  function updateDatas() {
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
        // console.log(animation.datas[nImage]);
      }
    });
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }

  function record() {
    if (!enLecture) {
      console.log("lecture");
      animation.datas[nImage] = [];
      // enregistre l'état
      pixels.forEach((pixel, i) => {
        if (pixel.classList.contains("allume")) {
          animation.datas[nImage].push(i + 1);
          // console.log(animation.datas[nImage]);
        }
      });
      enLecture = true;
      requestAnimationFrame(lire);
    } else {
      enLecture = false;
      nImageLecteur = 0;
      // met à jour le compteur
      compteur.innerHTML = nImage;
      // éteint les pixels
      pixels.forEach((pixel) => {
        pixel.classList.remove("allume");
      });
      // allume les pixels (image de l'animation)
      animation.datas[nImage].forEach((pixel) => {
        pixels[pixel - 1].classList.add("allume");
      });
      // MàJ de l'afficheur XY5 si connecté
      if (writer !== undefined) {
        updateXY5(nImage);
      }
    }
  }

  function next() {
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
        // console.log(animation.datas[nImage]);
      }
    });
    // si l'image existe
    if (animation.datas[nImage + 1] !== undefined) {
      // passe à l'image suivante
      nImage++;
      // met à jour le compteur
      compteur.innerHTML = nImage;
      // efface la précédente image
      pixels.forEach((pixel) => {
        pixel.classList.remove("allume");
      });
      // allume les pixels (image de l'animation)
      animation.datas[nImage].forEach((pixel) => {
        pixels[pixel - 1].classList.add("allume");
      });
      // MàJ de l'afficheur XY5 si connecté
      if (writer !== undefined) {
        updateXY5(nImage);
      }
    } else {
      feedback();
    }
  }

  function previous() {
    if (nImage > 0) {
      animation.datas[nImage] = [];
      // enregistre l'état actuel
      pixels.forEach((pixel, i) => {
        if (pixel.classList.contains("allume")) {
          animation.datas[nImage].push(i + 1);
          // console.log(animation.datas[nImage]);
        }
      });
      nImage--;
      // met à jour le compteur
      compteur.innerHTML = nImage;
      // si l'image existe
      if (animation.datas[nImage] !== undefined) {
        // éteint les pixels
        pixels.forEach((pixel) => {
          pixel.classList.remove("allume");
        });
        // allume les pixels (image de l'animation)
        animation.datas[nImage].forEach((pixel) => {
          pixels[pixel - 1].classList.add("allume");
        });
        // MàJ de l'afficheur XY5 si connecté
        if (writer !== undefined) {
          updateXY5(nImage);
        }
      } else {
        console.log("fin de l'anim");
      }
    } else {
      feedback();
      // setTimeout(() => {document.body.style.backgroundColor = "var(--fondApp)";}, 40);
    }
  }

  function feedback() {
    document.body.style.transition = "none";
    document.body.style.backgroundColor = "var(--alerte)";
    setTimeout(() => {
      document.body.style.transition = "background-color 224ms ease-out";
      document.body.style.backgroundColor = "var(--fondApp)";
    }, 20);
  }

  function saveAnimation(e) {
    console.log(e);
    const dt = new Date();
    // console.log('animation@'+dt.YYYYMMDDHHMMSS());
    const name = `animation@${dt.YYYYMMDDHHMMSS()}`;
    // const name = 'anim';
    const text = JSON.stringify(animation);

    // e.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    // e.setAttribute('download', `${name.toLowerCase()}.txt`);

    e.setAttribute('href', `data:application/json;charset=utf-8,${encodeURIComponent(text)}`);
    e.setAttribute('download', `${name.toLowerCase()}.json`);
  }

  // inits animation
  let oldDuree = null;
  nImageLecteur = 0;
  let first = true;
  const hauteur = document.querySelector("#hauteur");
  const largeur = document.querySelector("#largeur");

  function connectSerial() {
    navigator.serial.requestPort()
      .then((port) => {
        // Connect to `port` or add it to the list of available ports.
        // Wait for the serial port to open.
        port.open({
          baudRate: 57600,
          dataBits: 8,
          stopBits: 1,
          parity: 'none',
        }).then(() => {
          // succès
          document.querySelector('#serial').style.display = 'none';
          document.querySelector('#size').classList.add("sizeMatrix");
          document.querySelector('#rot').classList.add("showMatrix");
          // const writer = port.writable.getWriter();
          writer = port.writable.getWriter();
          updateXY5(nImage);
          // Allow the serial port to be closed later.
          // writer.releaseLock();
        })
          .catch((e) => {
            console.log("erreur ouverture du port série : ", e);
          });
      })
      .catch((e) => {
        // The user didn't select a port.
        console.log("ERREUR : pas de port série sélectionné :", e);
      });
  }
  // MàJ de l'afficheur XY5
  function updateXY5(nImg) {
    // rempli l'array de zero
    const image = Array(animation.dim[0]).fill(0);
    // allume les pixels (image de l'animation)
    animation.datas[nImg].forEach((pixel, n) => {
      // pixels[pixel - 1].classList.add("allume");
      // console.log("pixel:", pixel, n);
      const x = (pixel - 1) % animation.dim[0];
      const y = Math.floor((pixel - 1) / animation.dim[0]);
      image[y] += (1<<x); // eslint-disable-line no-bitwise
    });
    const frame = buildFrameBuffer(image);
    // console.log(frame);
    writer.write(frame);
  }

  function lire(timestamp) {
    if (animation.datas.length > 1) {
      // actions.style.opacity = .3;
      //console.log("lecture");
      const msPassees = timestamp - oldDuree;
      if (enLecture) {
        if (first) {
          nImageLecteur = nImage;
          first = false;
          if (mode === 'player') {
            actions.style.opacity = 0;
          }
          // if (mode == "player") {
          //   actions.style.left = "calc(calc(100vw - 110px) - 2rem)";
          // } else {
          //   actions.style.left = "calc(calc(100vw - 180px) - 2rem)";
          // }
          // actions.style.right = "2rem";
        }
        requestAnimationFrame(lire);
        if (msPassees > 1000 / fps) {
          // affiche le numero d'image
          compteur.innerHTML = nImageLecteur % animation.datas.length;
          // éteint les pixels
          pixels.forEach((pixel) => {
            pixel.classList.remove("allume");
          });

          if (writer !== undefined) {
            updateXY5(nImageLecteur);
          }
          animation.datas[nImageLecteur].forEach((pixel, n) => {
            pixels[pixel - 1].classList.add("allume");
            // console.log("pixel:", pixel, n);
          });

          nImageLecteur++;
          nImageLecteur %= animation.datas.length;
          oldDuree = timestamp;
        }
      } else {
        // if (mode=='player') {
        actions.style.opacity = 1;
        // }
        first = true;
        console.log("en pause");
        enLecture = false;
        nImageLecteur = animation.datas.length - 1;
        nImage = animation.datas.length - 1;
        // affiche le numero d'image
        compteur.innerHTML = nImageLecteur;
        // éteint les pixels
        pixels.forEach((pixel) => {
          pixel.classList.remove("allume");
        });
        if (writer !== undefined) {
          updateXY5(nImageLecteur);
        }
        // allume les pixels (image de l'animation)
        animation.datas[nImageLecteur].forEach((pixel) => {
          pixels[pixel - 1].classList.add("allume");
        });
      }
    }
  }

  function erase() {
    // efface l'image de l'animation
    animation.datas.splice(nImage, 1);
    // si l'image existe
    if (animation.datas[nImage] !== undefined) {
      console.log("existe");
    } else {
      // si l'image n'existe pas (efface la dernière image)
      nImage--;
      compteur.innerHTML = nImage;
    }
    // mets à jour l'affichage
    // efface la précédente- image
    pixels.forEach((pixel) => {
      pixel.classList.remove("allume");
    });
    if (writer !== undefined) {
      updateXY5(nImage);
    }
    // allume les pixels (image de l'animation)
    animation.datas[nImage].forEach((pixel) => {
      pixels[pixel - 1].classList.add("allume");
    });
  }

  function addFrame() {
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
        // console.log(animation.datas[nImage]);
      }
    });
    // console.log(animation.datas);
    animation.datas.splice(nImage + 1, 0, []);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
    nImage++;
    // met à jour le compteur
    compteur.innerHTML = nImage % animation.datas.length;
    // console.log(animation.datas);
    // éteint les pixels
    if (clearNF.checked) {
      pixels.forEach((pixel) => {
        pixel.classList.remove("allume");
      });
    }
    updateDatas();
  }
  /* outils de dessin */
  function pixToggle() {
    pixels.forEach((pixel) => {
      pixel.classList.toggle("allume");
    });
    // maj de l'image dans les datas
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
      }
    });
    // console.log(animation.datas[nImage]);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }

  function pixRight() {
    // init la matrice
    pixels.forEach((pixel) => {
      pixel.classList.remove("allume");
    });
    animation.datas[nImage].forEach((pixel, n) => {
      if (Math.floor((pixel-1)/animation.dim[0]) === Math.floor(pixel/animation.dim[0])) {
        pixels[pixel].classList.add("allume");
        // console.log("pixel:", pixel, n);
      }
    });
    // maj de l'image dans les datas
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
      }
    });
    // console.log(animation.datas[nImage]);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }

  function pixLeft() {
    // init la matrice
    pixels.forEach((pixel) => {
      pixel.classList.remove("allume");
    });
    animation.datas[nImage].forEach((pixel, n) => {
      if (Math.floor((pixel-2)/animation.dim[0]) === Math.floor((pixel-1)/animation.dim[0])) {
        pixels[pixel-2].classList.add("allume");
        // console.log("pixel:", pixel, n);
      }
    });
    // maj de l'image dans les datas
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
      }
    });
    // console.log(animation.datas[nImage]);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }

  function pixUp() {
    // init la matrice
    pixels.forEach((pixel) => {
      pixel.classList.remove("allume");
    });
    animation.datas[nImage].forEach((pixel, n) => {
      if (pixel >= (animation.dim[0]+1)) {
        pixels[pixel-(animation.dim[0]+1)].classList.add("allume");
        // console.log("pixel:", pixel, n);
      }
    });
    // maj de l'image dans les datas
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
      }
    });
    // console.log(animation.datas[nImage]);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }

  function pixDown() {
    // init la matrice
    pixels.forEach((pixel) => {
      pixel.classList.remove("allume");
    });
    animation.datas[nImage].forEach((pixel, n) => {
      if (pixel <= ((animation.dim[1]-1)*animation.dim[0])) {
        pixels[pixel+(animation.dim[0]-1)].classList.add("allume");
        // console.log("pixel:", pixel, n);
      }
    });
    // maj de l'image dans les datas
    animation.datas[nImage] = [];
    // enregistre l'état
    pixels.forEach((pixel, i) => {
      if (pixel.classList.contains("allume")) {
        animation.datas[nImage].push(i + 1);
      }
    });
    // console.log(animation.datas[nImage]);
    if (writer !== undefined) {
      updateXY5(nImage);
    }
  }
  /* fin des outils de dessin */

  function ferme() {
    console.log("click");
    size.style.display = "none";
  }

  function majDim(e) {
    console.log(e.id);
    document.querySelector(`#${e.id}Txt`).innerHTML = e.value;
    rows = hauteur.value;
    cols = largeur.value;
    animation.dim[1] = parseInt(hauteur.value, 10);
    animation.dim[0] = parseInt(largeur.value, 10);
    dessineGrille();
  }

  function majVitesse(e) {
    // console.log(e.id);
    document.querySelector(`#${e.id}Txt`).innerHTML = e.value;
    fps = e.value;
    animation.speed = e.value;
  }

  function dessineGrille() {
    console.log("dessine");
    // efface table pixels
    pixels = [];
    // dimensionne la grille css
    main.style.gridTemplateColumns = `repeat(${cols}, minmax(0,1fr))`;
    main.innerHTML = "";
    // création  de la grille
    for (let i = 0; i < rows * cols; i++) {
      const pixel = document.createElement("article");
      pixel.id = `c_${i}`;
      pixel.dataset.x = i%cols;
      pixel.dataset.y = Math.floor(i/cols);
      // console.log("gridgap:",parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')));
      // dépend de la largeur du grid-gap (mode player/editeur)
      // pixel.style.height = `calc(${50 / rows}vh - ${((rows-1)/rows)*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'))}rem)`;
      pixels.push(pixel);
      pixel.addEventListener("click", switchPixel);
      main.appendChild(pixel);
    }
    // rempli les dimensions l'animation
    animation.dim[0] = parseInt(cols, 10);
    animation.dim[1] = parseInt(rows, 10);
    document.querySelector(`#largeurTxt`).innerHTML = parseInt(cols, 10);
    document.querySelector(`#hauteurTxt`).innerHTML = parseInt(rows, 10);
    document.querySelector("#largeur").value = parseInt(cols, 10);
    document.querySelector("#hauteur").value = parseInt(rows, 10);
  }

  function importe(input) {
    enLecture = false;
    // console.log("importe");
    const file = input.files[0];
    // input.blur();
    const reader = new FileReader();

    reader.readAsText(file);

    reader.onload = () => {
      console.log(reader.result);
      try {
        const obj = JSON.parse(reader.result);
        animation = {};
        animation.dim = obj.dim;
        animation.datas = obj.datas;
        // ajout de la vitesse si dispo dans le fichier (version du fichier) et MàJ le range et la valeur
        console.log("vitesse:", obj.speed);
        if (obj.speed !== undefined) {
          animation.speed = obj.speed;
          fps = obj.speed;
          speedR.value = obj.speed;
          speedP.innerHTML = obj.speed;
        }
        // compare grille aux valeurs de datas
        let valMax = 0;
        obj.datas.forEach((item) => {
          item.forEach((num) => {
            if (valMax < num) {
              valMax = num;
            }
          });
        });
        console.log("valMax=", valMax);
        if (valMax > obj.dim[1] * obj.dim[0]) {
          animation = {
            speed: 8,
            dim: [],
            datas: [],
          };
          throw new Error(`la taille de la grille ${obj.dim[0]} par ${obj.dim[1]} dans le fichier est inférieur aux valeurs de l'animation`);
        }
        [, rows] = obj.dim; // obj.dim[1]
        [cols] = obj.dim; // obj.dim[0]
        nImageLecteur = 0;
        nImage = animation.datas.length - 1;
        dessineGrille();
        // allume les pixels (de la dernière image de l'animation)
        animation.datas[nImage].forEach((pixel) => {
          pixels[pixel - 1].classList.add("allume");
        });
        if (writer !== undefined) {
          updateXY5(nImage);
        }
        // met à jour le compteur
        compteur.innerHTML = nImage;
        // console.log(obj.datas.length,animation.datas);
      } catch (err) {
        alert(`Il y a un problème dans le fichier, l'import n'a pas fonctionné.\nVérifiez votre fichier\n\n${err}`);
      }
    };

    reader.onerror = () => {
      console.log(reader.error);
      alert("il y a un problème dans le fichier, l'import n'a pas fonctionné. Vérifiez votre fichier\n", reader.error);
    };
  }
  // formatage du nom du fichier

  function pad(number, length) {
    let str = `${number}`;
    while (str.length < length) {
      str = `0${str}`;
    }
    return str;
  }

  Date.prototype.YYYYMMDDHHMMSS = function () {
    const yyyy = this.getFullYear().toString();
    const MM = pad(this.getMonth() + 1, 2);
    const dd = pad(this.getDate(), 2);
    const hh = pad(this.getHours(), 2);
    const mm = pad(this.getMinutes(), 2);
    const ss = pad(this.getSeconds(), 2);
    return yyyy + MM + dd + hh + mm + ss;
  };

  /* Command/Control + Shift */
  window.addEventListener("keydown", (event) => {
    // console.log(event, event.ctrlKey);
    if (event.shiftKey) {
      shift = true;
    }
    if (event.metaKey) {
      meta = true;
      document.documentElement.style.setProperty('--curseur', 'ew-resize');
      if (shift) {
        document.documentElement.style.setProperty('--curseur', 'ns-resize');
      }
    }
  });
  /* équivalents clavier */
  window.addEventListener("keyup", (event) => {
    // console.log("keyup: ", event.code);
    switch (event.code) {
      case "Space":
        record();
        break;
      case "ArrowLeft":
        previous();
        break;
      case "ArrowRight":
        next();
        break;
      case "Enter":
      case "KeyQ": // ça devrait être un A sur un clavier US
        addFrame();
        break;
      case "Backspace":
        erase();
        break;
      case "Escape":
        console.log("escape");
        actions.style.opacity = 1;
        enLecture = false;
        lire();
        break;
      case "ShiftLeft":
      case "ShiftRight":
        shift = false;
        if (!meta) {
          document.documentElement.style.setProperty('--curseur', 'pointer');
        } else {
          document.documentElement.style.setProperty('--curseur', 'ew-resize');
        }
        break;
      case "MetaLeft":
      case "MetaRight":
        meta = false;
        document.documentElement.style.setProperty('--curseur', 'pointer');
        break;
      default:
    }
  });

  /* passage en mode player */
  window.addEventListener('hashchange', (e) => {
    console.log(e.oldURL, e.newURL, /player/g.test(e.newURL));
    if (/player/g.test(e.newURL)) {
      mode = "player";
      size.style.display = "none";
      actions.style.width = "220px";
      actions.style.left = "calc(calc(50vw - 110px) - .5rem)";
      document.querySelector('#download').style.display = "none";
      document.querySelector('#add').style.display = "none";
      document.querySelector('#clearNewFrame').style.display = "none";
      document.querySelector('#clearNewFrameLabel').style.display = "none";
      document.querySelector('#erase').style.display = "none";
      document.documentElement.style.setProperty('--gap', 0);
      document.documentElement.style.setProperty('--fond', "#000");
      // pixels.forEach((pixel) => {
      //   pixel.style.height = `calc(${100 / rows}vh - ${((rows-1)/rows)*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'), 10)}rem)`;
      // });
      document.body.style.backgroundColor = "#333";
      document.querySelector('#uploadPlayer').style.display = "block";
    } else {
      mode = "editeur";
      size.style.display = "flex";
      actions.style.opacity = 1;
      actions.style.width = "360px";
      actions.style.left = "calc(calc(50vw - 180px) - .5rem)";
      document.querySelector('#download').style.display = "block";
      document.querySelector('#add').style.display = "block";
      document.querySelector('#clearNewFrame').style.display = "block";
      document.querySelector('#clearNewFrameLabel').style.display = "block";
      document.querySelector('#erase').style.display = "block";
      document.documentElement.style.setProperty('--gap', "1rem");
      document.documentElement.style.setProperty('--fond', "#333");
      // pixels.forEach((pixel) => {
      //   pixel.style.height = `calc(${100 / rows}vh - ${((rows-1)/rows)*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'), 10)}rem)`;
      // });
      document.body.style.backgroundColor = "#000";
      mode = "editeur";
      document.querySelector('#uploadPlayer').style.display = "none";
    }
  }, false);

  /* sauvegarde de l'anim automatique avant de quitter (ou fausse manip) */
  window.onbeforeunload = () => {
    // sauvegarde la dernière animation
    window.localStorage.animation = JSON.stringify(animation);
  };
  /* recharge la dernière anim sauvegardée */
  window.addEventListener('load', () => {
    if (window.localStorage.animation !== undefined) {
      if (confirm('Voulez-vous recharger la dernière animation ?')) {
        // recharge l'animation sauvegardée
        const obj = JSON.parse(window.localStorage.animation);
        // JSON.parse(reader.result);
        animation = {};
        animation.dim = obj.dim;
        animation.datas = obj.datas;
        // ajout de la vitesse si dispo dans le fichier (version du fichier) et MàJ le range et la valeur
        console.log("vitesse:", obj.speed);
        if (obj.speed !== undefined) {
          animation.speed = obj.speed;
          fps = obj.speed;
          speedR.value = obj.speed;
          speedP.innerHTML = obj.speed;
        }
        // compare grille aux valeurs de datas
        let valMax = 0;
        obj.datas.forEach((item) => {
          item.forEach((num) => {
            if (valMax < num) {
              valMax = num;
            }
          });
        });
        [, rows] = obj.dim; // obj.dim[1]
        [cols] = obj.dim; // obj.dim[0]
        nImageLecteur = 0;
        nImage = animation.datas.length - 1;
        dessineGrille();
        // allume les pixels (de la dernière image de l'animation)
        animation.datas[nImage].forEach((pixel) => {
          pixels[pixel - 1].classList.add("allume");
        });
        if (writer !== undefined) {
          updateXY5(nImage);
        }
        // met à jour le compteur
        compteur.innerHTML = nImage;
        console.log('Thing was saved to the database.');
      } else {
        // Do nothing!
        window.localStorage.removeItem(animation);
        console.log("efface l'animation sauvegardée");
      }
    }
  });
  </script>

</html>
